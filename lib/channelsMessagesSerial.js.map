{"version":3,"file":"channelsMessagesSerial.js","sources":["../src/store/modules/channelsMessagesSerial/index.js","../src/store/modules/channelsMessagesSerial/actions.js","../src/store/modules/channelsMessagesSerial/mutations.js"],"sourcesContent":["import getActions from './actions'\nimport getMutations from './mutations'\n\nexport default function ({ Vue, LocalStorage, name, errorHandler, filterHandler, newMessagesInterseptor }) {\n  let actions = getActions({ Vue, LocalStorage, errorHandler }),\n    mutations = getMutations({ Vue, LocalStorage, filterHandler, newMessagesInterseptor })\n\n  const state = {\n    name: name,\n    isLoading: false,\n    active: 0,\n    messages: [],\n    filter: '',\n    sysFilter: '',\n    settings: {},\n    mode: null,\n    from: 0,\n    to: 0,\n    limit: 1000,\n    reverse: false,\n    cols: [],\n    newMessagesCount: 0,\n    offline: false,\n    selected: [],\n    sortBy: null\n  }\n\n  return {\n    namespaced: true,\n    state,\n    actions,\n    mutations\n  }\n}\n","export default function ({ Vue, LocalStorage, errorHandler }) {\n  function getParams (state) {\n    let params = {}\n    if (state.limit) {\n      params.count = state.limit\n    }\n    if (state.filter && state.sysFilter) {\n      if (state.mode === 1) {\n        params.filter = `${state.sysFilter}`\n      } else {\n        params.filter = `${state.sysFilter},${state.filter}`\n      }\n    } else if (state.sysFilter && !state.filter) {\n      params.filter = `${state.sysFilter}`\n    } else if (!state.sysFilter && state.filter) {\n      if (state.mode === 0) {\n        params.filter = `${state.filter}`\n      }\n    }\n    if (state.from && (!state.reverse || state.mode === 1)) {\n      if (!state.reverse) {\n        params.from = Math.floor(state.from / 1000)\n      }\n    }\n    if (state.to) {\n      if (state.mode === 1) {\n        state.to = Date.now()\n      }\n      params.to = Math.floor(state.to / 1000)\n    }\n    if (state.reverse) {\n      params.reverse = state.reverse\n    }\n    return params\n  }\n\n  function errorsCheck (data) {\n    if (data.errors) {\n      data.errors.forEach((error) => {\n        let errObject = new Error(error.reason)\n        errorHandler && errorHandler(errObject)\n      })\n    }\n  }\n\n  async function getCols ({ state, commit, rootState }) {\n    commit('reqStart')\n    if (rootState.token && state.active) {\n      try {\n        Vue.set(state, 'isLoading', true)\n        let cols = [],\n          colsFromStorage = LocalStorage.get.item(state.name)\n        if (colsFromStorage && colsFromStorage[state.active] && colsFromStorage[state.active]) {\n          /* remove after sometime 12.07.19 */\n          colsFromStorage[state.active].forEach((col) => {\n            if (col.name === 'timestamp') {\n              let locale = new Date().toString().match(/([-\\+][0-9]+)\\s/)[1]\n              col.addition = `${locale.slice(0, 3)}:${locale.slice(3)}`\n            }\n          })\n          cols = colsFromStorage[state.active]\n        } else {\n          let protocolIdResp = await Vue.connector.gw.getChannels(state.active, { fields: 'protocol_id' })\n          let protocolIdData = protocolIdResp.data\n          errorsCheck(protocolIdData)\n          if (protocolIdData.result && protocolIdData.result.length && protocolIdData.result[0].protocol_id) {\n            let colsResp = await Vue.connector.gw.getProtocols(protocolIdData.result[0].protocol_id, { fields: 'message_parameters' })\n            let colsData = colsResp.data\n            errorsCheck(colsData)\n            colsData.result[0].message_parameters.forEach(col => {\n              let colItem = {\n                name: col.name,\n                width: 160,\n                display: true,\n                description: col.info\n              }\n              if (colItem.name === 'timestamp') {\n                let locale = new Date().toString().match(/([-\\+][0-9]+)\\s/)[1]\n                colItem.addition = `${locale.slice(0, 3)}:${locale.slice(3)}`\n              }\n              cols.push(colItem)\n            })\n          }\n        }\n        commit('setCols', cols)\n        Vue.set(state, 'isLoading', false)\n      } catch (e) {\n        errorHandler && errorHandler(e)\n        if (DEV) { console.log(e) }\n        Vue.set(state, 'isLoading', false)\n      }\n    }\n  }\n\n  function getFromTo (val) {\n    let now = val || Date.now(),\n      from = new Date(now).setHours(0, 0, 0, 0),\n      to = from + 86400000\n    return { from, to }\n  }\n\n  async function initTime ({ state, commit, rootState }) {\n    if (rootState.token && state.active) {\n      try {\n        Vue.set(state, 'isLoading', true)\n        let params = {\n          reverse: true,\n          count: 1\n        }\n        let resp = await Vue.connector.gw.getChannelsMessages(state.active, { data: JSON.stringify(params) })\n        let data = resp.data\n        errorsCheck(data)\n        let date = Date.now()\n        if (data.result.length) {\n          date = Math.round(data.result[0].timestamp * 1000)\n        }\n        commit('setDate', getFromTo(date).from)\n        Vue.set(state, 'isLoading', false)\n      } catch (e) {\n        errorHandler && errorHandler(e)\n        if (DEV) { console.log(e) }\n        Vue.set(state, 'isLoading', false)\n      }\n    }\n  }\n\n  async function get ({ state, commit, rootState }, preaction) {\n    commit('reqStart')\n    if (preaction) {\n      let { name: preactionName, payload: preactionPayload } = preaction\n      commit('clearMessages')\n      commit(preactionName, preactionPayload)\n    }\n    if (rootState.token && state.active) {\n      try {\n        Vue.set(state, 'isLoading', true)\n        let currentMode = JSON.parse(JSON.stringify(state.mode))\n        let resp = await Vue.connector.gw.getChannelsMessages(state.active, { data: JSON.stringify(getParams(state)) })\n        /* if mode changed in time request */\n        if (currentMode !== state.mode) { return false }\n        let data = resp.data\n        errorsCheck(data)\n        if (preaction) {\n          if (data.result.length) {\n            commit('setMessages', data.result)\n            commit('postaction')\n          } else {\n            commit('postaction')\n            switch (preaction.name) { // logic for empty response after pagination scroll\n              case 'paginationPrev': {\n                commit('datePrev')\n                commit('paginationPrev')\n                await get({ state, commit, rootState })\n                commit('postaction')\n                break\n              }\n              case 'paginationNext': {\n                get({ state, commit, rootState }, { name: 'dateNext' })\n                commit('postaction')\n                break\n              }\n              default: {\n                commit('setMessages', data.result)\n                commit('postaction')\n              }\n            }\n          }\n        } else {\n          commit('setMessages', data.result)\n        }\n        Vue.set(state, 'isLoading', false)\n      } catch (e) {\n        errorHandler && errorHandler(e)\n        if (DEV) { console.log(e) }\n        Vue.set(state, 'isLoading', false)\n      }\n    }\n  }\n\n  async function getHistory ({ state, commit, rootState }, count) {\n    let limit = state.limit,\n      filter = state.filter\n    commit('setReverse', true)\n    commit('setLimit', count)\n    commit('setFilter', '')\n    await get({ state, commit, rootState })\n    commit('setReverse', false)\n    commit('setLimit', limit)\n    commit('setFilter', filter)\n  }\n\n  let messagesBuffer = [],\n    loopId = 0\n  function initRenderLoop (state, commit) {\n    return setInterval(() => {\n      if (messagesBuffer.length) {\n        if (state.mode === 1) {\n          commit('setMessages', [...messagesBuffer])\n        }\n        messagesBuffer = []\n      }\n    }, 500)\n  }\n\n  async function pollingGet ({ state, commit, rootState }) {\n    loopId = initRenderLoop(state, commit)\n    await Vue.connector.subscribeMessagesChannels(state.active, '+', (message) => {\n      if (state.mode === 1) {\n        messagesBuffer.push(JSON.parse(message))\n      } else {\n        commit('setNewMessagesCount', state.newMessagesCount + 1)\n      }\n    }, { rh: 2 })\n  }\n\n  /* unsubscribe from current active topic */\n  async function unsubscribePooling ({ state }) {\n    if (loopId) { clearInterval(loopId) }\n    await Vue.connector.unsubscribeMessagesChannels(state.active, '+')\n  }\n\n  /* getting missed messages after offline */\n  async function getMissedMessages ({ state, commit, rootState }) {\n    if (rootState.token && state.active) {\n      try {\n        Vue.set(state, 'isLoading', true)\n        let lastIndexOffline = state.messages.reduceRight((result, value, index) => {\n          if (result) {\n            return result\n          }\n          if (value.__connectionStatus === 'offline') {\n            result = index\n          }\n          return result\n        }, 0)\n        let params = {\n          from: !lastIndexOffline ? 0 : Math.floor(state.messages[lastIndexOffline - 1].timestamp) + 1,\n          to: Math.floor(state.messages[lastIndexOffline + 1].timestamp)\n        }\n        let resp = await Vue.connector.gw.getChannelsMessages(state.active, { data: JSON.stringify(params) })\n        let data = resp.data\n        errorsCheck(data)\n        commit('setMissingMessages', { data: data.result, index: lastIndexOffline })\n        Vue.set(state, 'isLoading', false)\n      } catch (e) {\n        errorHandler && errorHandler(e)\n        if (DEV) { console.log(e) }\n        Vue.set(state, 'isLoading', false)\n      }\n    }\n  }\n\n  return {\n    get,\n    pollingGet,\n    getCols,\n    getHistory,\n    initTime,\n    unsubscribePooling,\n    getMissedMessages\n  }\n}\n","export default function ({ Vue, LocalStorage, filterHandler, newMessagesInterseptor }) {\n  function getFromTo (val) {\n    let now = val || Date.now(),\n      from = new Date(now).setHours(0, 0, 0, 0),\n      to = from + 86400000\n    return { from, to }\n  }\n\n  function setMessages (state, data) {\n    if (data && data.length) {\n      if (state.reverse) {\n        data.reverse()\n        if (state.mode === 1) {\n          data[data.length - 1].delimiter = true\n        }\n      }\n      if (state.mode === 1) {\n        Vue.set(state, 'from', Math.floor((data[data.length - 1].timestamp + 1) * 1000))\n        if (state.filter && filterHandler) {\n          data = filterHandler(state.filter, data)\n        }\n      }\n      let messages = state.messages\n      if (state.sortBy && state.mode === 1) {\n        if (data.length > 1) {\n          /* write history for rt mode */\n          messages = messages.concat(data)\n        } else {\n          /* write by sorted field */\n          let message = data[0],\n            fieldName = state.sortBy,\n            length = state.messages.length - 1,\n            index = null,\n            escapeFlag = true\n          if (length > 0) {\n            for (let i = length; i !== 0 || escapeFlag; i--) {\n              if (messages[i][fieldName] > message[fieldName]) {\n                index = i\n                if (i === 0) {\n                  escapeFlag = false\n                }\n              } else {\n                escapeFlag = false\n              }\n            }\n          }\n          if (index) {\n            messages.splice(index, 0, message)\n          } else {\n            messages.push(message)\n          }\n        }\n      } else {\n        messages = messages.concat(data)\n      }\n      newMessagesInterseptor && newMessagesInterseptor(data)\n      if (state.limit && state.mode === 1 && messages.length >= state.limit + (state.limit * 0.1)) { // rt limiting\n        let count = (messages.length - 1) - (state.limit - 1)\n        messages = messages.slice(count)\n        Vue.set(state, 'selected', state.selected.map((index) => index - count))\n      }\n      Vue.set(state, 'messages', messages)\n    } else {\n      if (state.mode === 1) {\n        Vue.set(state, 'from', state.to + 1000)\n      }\n      Vue.set(state, 'messages', [])\n    }\n  }\n\n  function clearMessages (state) {\n    Vue.set(state, 'messages', [])\n    newMessagesInterseptor && newMessagesInterseptor([])\n    clearSelected(state)\n  }\n\n  function setLimit (state, count) {\n    Vue.set(state, 'limit', count)\n  }\n\n  function setFilter (state, value) {\n    if (state.filter !== value) {\n      if (state.mode === 1) {\n        if (state.filter) {\n          state.messages.push({ 'x-flespi-filter-prev': state.filter })\n        }\n        if (value) {\n          state.messages.push({ 'x-flespi-filter-next': value })\n        }\n      }\n      Vue.set(state, 'filter', value)\n    }\n  }\n\n  function setMode (state, mode) {\n    switch (mode) {\n      case 0: {\n        let timeObj = state.from ? getFromTo(state.from) : getFromTo()\n        state.from = timeObj.from\n        state.to = timeObj.to\n        clearMessages(state)\n        break\n      }\n      case 1: {\n        let now = Date.now() - 4000\n        state.from = now - 1000\n        state.to = now\n        state.newMessagesCount = 0\n        break\n      }\n    }\n    Vue.set(state, 'mode', mode)\n  }\n\n  function setFrom (state, from) {\n    Vue.set(state, 'from', from)\n  }\n\n  function setTo (state, to) {\n    Vue.set(state, 'to', to)\n  }\n\n  function reqStart () {\n    if (DEV) {\n      console.log('Start Request Channels messages')\n    }\n  }\n\n  function setActive (state, id) {\n    state.newMessagesCount = 0\n    Vue.set(state, 'active', id)\n  }\n\n  function setReverse (state, val) {\n    Vue.set(state, 'reverse', val)\n  }\n\n  function setDate (state, date) {\n    let timeObj = getFromTo(date)\n    state.from = timeObj.from\n    state.to = timeObj.to\n  }\n\n  function dateNext (state) {\n    let timeObj = getFromTo(state.from + 86400000)\n    state.from = timeObj.from\n    state.to = timeObj.to\n  }\n\n  function datePrev (state) {\n    let timeObj = getFromTo(state.from - 86400000)\n    state.from = timeObj.from\n    state.to = timeObj.to\n  }\n\n  function paginationPrev (state, firstTimestamp) {\n    state.reverse = true\n    state.sysFilter += `timestamp>=${getFromTo(state.from).from / 1000}`\n    if (firstTimestamp) {\n      state.from = getFromTo(firstTimestamp).from\n      state.to = firstTimestamp - 1000\n    }\n  }\n\n  function paginationNext (state, lastTimestamp) {\n    state.sysFilter += `timestamp<=${state.to / 1000}`\n    if (lastTimestamp) {\n      state.to = getFromTo(lastTimestamp).to\n      state.from = lastTimestamp + 1000\n    }\n  }\n\n  function postaction (state) {\n    let timeObj = getFromTo(state.from)\n    setFrom(state, state.from || timeObj.from)\n    setTo(state, timeObj.to)\n    if (state.reverse) {\n      setReverse(state, false)\n    }\n    state.sysFilter = ''\n  }\n\n  async function clear (state) {\n    clearMessages(state)\n    state.filter = ''\n    state.mode = null\n    state.from = 0\n    state.to = 0\n    state.limit = 1000\n    state.reverse = false\n    await Vue.connector.unsubscribeMessagesChannels(state.active)\n  }\n\n  function setCols (state, cols) {\n    let colsFromStorage = LocalStorage.get.item(state.name)\n    if (!colsFromStorage) {\n      colsFromStorage = {}\n    }\n    colsFromStorage[state.active] = cols\n    LocalStorage.set(state.name, colsFromStorage)\n    Vue.set(state, 'cols', cols)\n  }\n\n  function setSettings (state, channel) {\n    Vue.set(state, 'settings', channel)\n  }\n\n  let updateCols = setCols\n\n  function setNewMessagesCount (state, count) {\n    Vue.set(state, 'newMessagesCount', count)\n  }\n\n  function setOffline (state, needPostOfflineMessage) {\n    if (needPostOfflineMessage) {\n      setMessages(state, [{ __connectionStatus: 'offline', timestamp: Date.now() / 1000 }])\n    }\n    state.offline = true\n  }\n\n  function setReconnected (state, needPostOfflineMessage) {\n    if (needPostOfflineMessage) {\n      setMessages(state, [{ __connectionStatus: 'reconnected', timestamp: Date.now() / 1000 }])\n    }\n    state.offline = false\n  }\n\n  function setMissingMessages (state, { data, index }) {\n    data.forEach((val) => {\n      val.__status = 'missed'\n    })\n    state.messages.splice(index + 1, 0, ...data)\n  }\n\n  function setSelected (state, indexes) {\n    Vue.set(state, 'selected', indexes)\n  }\n\n  function clearSelected (state) {\n    Vue.set(state, 'selected', [])\n  }\n\n  function setSortBy (state, field) {\n    Vue.set(state, 'sortBy', field)\n  }\n\n  function clearSortBy (state) {\n    Vue.set(state, 'sortBy', null)\n  }\n\n  return {\n    setOffline,\n    setReconnected,\n    setMissingMessages,\n    setMessages,\n    clearMessages,\n    setLimit,\n    setFilter,\n    setMode,\n    setFrom,\n    setTo,\n    reqStart,\n    setReverse,\n    dateNext,\n    datePrev,\n    paginationPrev,\n    paginationNext,\n    setDate,\n    postaction,\n    clear,\n    setActive,\n    setCols,\n    updateCols,\n    setNewMessagesCount,\n    setSelected,\n    clearSelected,\n    setSortBy,\n    clearSortBy,\n    setSettings\n  }\n}\n"],"names":["Vue","LocalStorage","name","errorHandler","filterHandler","newMessagesInterseptor","namespaced","state","isLoading","active","messages","filter","sysFilter","settings","mode","from","to","limit","reverse","cols","newMessagesCount","offline","selected","sortBy","actions","errorsCheck","data","errors","forEach","error","errObject","Error","reason","commit","rootState","token","set","colsFromStorage","get","item","col","locale","Date","toString","match","addition","slice","connector","gw","getChannels","fields","protocolIdResp","protocolIdData","result","length","protocol_id","getProtocols","colsResp","colsData","message_parameters","colItem","width","display","description","info","push","DEV","console","log","params","count","getChannelsMessages","JSON","stringify","resp","date","now","Math","round","timestamp","val","setHours","preaction","preactionName","preactionPayload","payload","currentMode","parse","floor","messagesBuffer","loopId","initRenderLoop","setInterval","subscribeMessagesChannels","message","rh","clearInterval","unsubscribeMessagesChannels","lastIndexOffline","reduceRight","value","index","__connectionStatus","pollingGet","getCols","getHistory","initTime","unsubscribePooling","getMissedMessages","getActions","mutations","getFromTo","setMessages","delimiter","concat","fieldName","escapeFlag","i","splice","map","clearMessages","clearSelected","setFrom","setTo","setReverse","setCols","setOffline","needPostOfflineMessage","setReconnected","setMissingMessages","__status","setLimit","setFilter","setMode","timeObj","reqStart","dateNext","datePrev","paginationPrev","firstTimestamp","paginationNext","lastTimestamp","setDate","postaction","clear","setActive","id","updateCols","setNewMessagesCount","setSelected","indexes","setSortBy","field","clearSortBy","setSettings","channel","getMutations"],"mappings":"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"}